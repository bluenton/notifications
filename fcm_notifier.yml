name: Firebase FCM Notifier

on:
  workflow_dispatch: # Allows manual triggering from GitHub UI
  schedule:
    - cron: '*/5 * * * *' # Runs every 5 minutes (adjust as needed)

jobs:
  run-notifier:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x' # Use a compatible Python version

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install firebase-admin # Install the Firebase Admin SDK

    - name: Run FCM Notifier Script
      env:
        # Securely pass your Firebase service account key as a JSON string
        # You MUST add this as a secret in your GitHub repository settings.
        # Name: FIREBASE_SERVICE_ACCOUNT_KEY
        # Value: The JSON content of your service account key file, minified into a single line.
        FIREBASE_SERVICE_ACCOUNT_KEY: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY }}
        # Pass FCM tokens if needed, though often retrieved from database by the script
        # FCM_REGISTRATION_TOKENS: "token1,token2" # Example for multiple tokens
      run: |
        python send_fcm_notification.py

    - name: Persist processed sessions (Optional, for more robust state management)
      # This step copies the processed_sessions.json back into the workspace
      # so that subsequent runs can access it.
      # Requires write permissions for the workflow.
      # For production, consider saving processed state directly to Firestore or another DB.
      run: |
        if [ -f processed_sessions.json ]; then
          mkdir -p ~/.processed_sessions
          mv processed_sessions.json ~/.processed_sessions/processed_sessions.json
        fi
      # This is commented out as it needs a more persistent storage solution
      # than the ephemeral GitHub Actions runner for production use.
      # It's here for conceptual understanding of state persistence.
      # You would need a separate storage mechanism like a Firestore collection
      # to store processed session IDs across different workflow runs.

